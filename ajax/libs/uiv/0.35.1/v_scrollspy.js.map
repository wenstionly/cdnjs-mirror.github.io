{"version":3,"file":"v_scrollspy.js","sources":["../src/utils/domUtils.js","../src/utils/arrayUtils.js","../src/directives/scrollspy/scrollspy.js"],"sourcesContent":["import {isExist, isString, isFunction} from './objectUtils'\n\nexport const EVENTS = {\n  MOUSE_ENTER: 'mouseenter',\n  MOUSE_LEAVE: 'mouseleave',\n  FOCUS: 'focus',\n  BLUR: 'blur',\n  CLICK: 'click',\n  INPUT: 'input',\n  KEY_DOWN: 'keydown',\n  KEY_UP: 'keyup',\n  KEY_PRESS: 'keypress',\n  RESIZE: 'resize',\n  SCROLL: 'scroll',\n  TOUCH_START: 'touchstart',\n  TOUCH_END: 'touchend'\n}\n\nexport const TRIGGERS = {\n  CLICK: 'click',\n  HOVER: 'hover',\n  FOCUS: 'focus',\n  HOVER_FOCUS: 'hover-focus',\n  OUTSIDE_CLICK: 'outside-click',\n  MANUAL: 'manual'\n}\n\nexport const PLACEMENTS = {\n  TOP: 'top',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  LEFT: 'left'\n}\n\nexport function isIE11 () {\n  return !!window.MSInputMethodContext && !!document.documentMode\n}\n\nexport function isIE10 () {\n  return window.navigator.appVersion.indexOf('MSIE 10') !== -1\n}\n\nexport function getComputedStyle (el) {\n  return window.getComputedStyle(el)\n}\n\nexport function getViewportSize () {\n  let width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)\n  let height = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)\n  return {width, height}\n}\n\nlet scrollbarWidth = null\nlet savedScreenSize = null\n\nexport function getScrollbarWidth (recalculate = false) {\n  let screenSize = getViewportSize()\n  // return directly when already calculated & not force recalculate & screen size not changed\n  if (scrollbarWidth !== null && !recalculate &&\n    screenSize.height === savedScreenSize.height && screenSize.width === savedScreenSize.width) {\n    return scrollbarWidth\n  }\n  if (document.readyState === 'loading') {\n    return null\n  }\n  const div1 = document.createElement('div')\n  const div2 = document.createElement('div')\n  div1.style.width = div2.style.width = div1.style.height = div2.style.height = '100px'\n  div1.style.overflow = 'scroll'\n  div2.style.overflow = 'hidden'\n  document.body.appendChild(div1)\n  document.body.appendChild(div2)\n  scrollbarWidth = Math.abs(div1.scrollHeight - div2.scrollHeight)\n  document.body.removeChild(div1)\n  document.body.removeChild(div2)\n  // save new screen size\n  savedScreenSize = screenSize\n  return scrollbarWidth\n}\n\nexport function on (element, event, handler) {\n  element.addEventListener(event, handler)\n}\n\nexport function off (element, event, handler) {\n  element.removeEventListener(event, handler)\n}\n\nexport function isElement (el) {\n  return el && el.nodeType === Node.ELEMENT_NODE\n}\n\nexport function removeFromDom (el) {\n  isElement(el) && isElement(el.parentNode) && el.parentNode.removeChild(el)\n}\n\nexport function ensureElementMatchesFunction () {\n  if (!Element.prototype.matches) {\n    Element.prototype.matches =\n      Element.prototype.matchesSelector ||\n      Element.prototype.mozMatchesSelector ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.oMatchesSelector ||\n      Element.prototype.webkitMatchesSelector ||\n      function (s) {\n        let matches = (this.document || this.ownerDocument).querySelectorAll(s)\n        let i = matches.length\n        while (--i >= 0 && matches.item(i) !== this) {\n        }\n        return i > -1\n      }\n  }\n}\n\nexport function addClass (el, className) {\n  if (!isElement(el)) {\n    return\n  }\n  if (el.className) {\n    let classes = el.className.split(' ')\n    if (classes.indexOf(className) < 0) {\n      classes.push(className)\n      el.className = classes.join(' ')\n    }\n  } else {\n    el.className = className\n  }\n}\n\nexport function removeClass (el, className) {\n  if (!isElement(el)) {\n    return\n  }\n  if (el.className) {\n    let classes = el.className.split(' ')\n    let newClasses = []\n    for (let i = 0, l = classes.length; i < l; i++) {\n      if (classes[i] !== className) {\n        newClasses.push(classes[i])\n      }\n    }\n    el.className = newClasses.join(' ')\n  }\n}\n\nexport function hasClass (el, className) {\n  if (!isElement(el)) {\n    return false\n  }\n  let classes = el.className.split(' ')\n  for (let i = 0, l = classes.length; i < l; i++) {\n    if (classes[i] === className) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function setDropdownPosition (dropdown, trigger, options = {}) {\n  let doc = document.documentElement\n  let containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0)\n  let containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n  let rect = trigger.getBoundingClientRect()\n  let dropdownRect = dropdown.getBoundingClientRect()\n  dropdown.style.right = 'auto'\n  dropdown.style.bottom = 'auto'\n  if (options.menuRight) {\n    dropdown.style.left = containerScrollLeft + rect.left + rect.width - dropdownRect.width + 'px'\n  } else {\n    dropdown.style.left = containerScrollLeft + rect.left + 'px'\n  }\n  if (options.dropup) {\n    dropdown.style.top = containerScrollTop + rect.top - dropdownRect.height - 4 + 'px'\n  } else {\n    dropdown.style.top = containerScrollTop + rect.top + rect.height + 'px'\n  }\n}\n\nexport function isAvailableAtPosition (trigger, popup, placement) {\n  let triggerRect = trigger.getBoundingClientRect()\n  let popupRect = popup.getBoundingClientRect()\n  let viewPortSize = getViewportSize()\n  let top = true\n  let right = true\n  let bottom = true\n  let left = true\n  switch (placement) {\n    case PLACEMENTS.TOP:\n      top = triggerRect.top >= popupRect.height\n      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2\n      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width\n      break\n    case PLACEMENTS.BOTTOM:\n      bottom = triggerRect.bottom + popupRect.height <= viewPortSize.height\n      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2\n      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width\n      break\n    case PLACEMENTS.RIGHT:\n      right = triggerRect.right + popupRect.width <= viewPortSize.width\n      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2\n      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height\n      break\n    case PLACEMENTS.LEFT:\n      left = triggerRect.left >= popupRect.width\n      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2\n      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height\n      break\n  }\n  return top && right && bottom && left\n}\n\nexport function setTooltipPosition (tooltip, trigger, placement, auto, appendToSelector, viewport) {\n  if (!isElement(tooltip) || !isElement(trigger)) {\n    return\n  }\n  const isPopover = tooltip && tooltip.className && tooltip.className.indexOf('popover') >= 0\n  let containerScrollTop\n  let containerScrollLeft\n  if (!isExist(appendToSelector) || appendToSelector === 'body') {\n    const doc = document.documentElement\n    containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0)\n    containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n  } else {\n    const container = document.querySelector(appendToSelector)\n    containerScrollLeft = container.scrollLeft\n    containerScrollTop = container.scrollTop\n  }\n  // auto adjust placement\n  if (auto) {\n    // Try: right -> bottom -> left -> top\n    // Cause the default placement is top\n    let placements = [PLACEMENTS.RIGHT, PLACEMENTS.BOTTOM, PLACEMENTS.LEFT, PLACEMENTS.TOP]\n    // The class switch helper function\n    const changePlacementClass = (placement) => {\n      // console.log(placement)\n      placements.forEach(placement => {\n        removeClass(tooltip, placement)\n      })\n      addClass(tooltip, placement)\n    }\n    // No need to adjust if the default placement fits\n    if (!isAvailableAtPosition(trigger, tooltip, placement)) {\n      for (let i = 0, l = placements.length; i < l; i++) {\n        // Re-assign placement class\n        changePlacementClass(placements[i])\n        // Break if new placement fits\n        if (isAvailableAtPosition(trigger, tooltip, placements[i])) {\n          placement = placements[i]\n          break\n        }\n      }\n      changePlacementClass(placement)\n    }\n  }\n  // fix left and top for tooltip\n  let rect = trigger.getBoundingClientRect()\n  let tooltipRect = tooltip.getBoundingClientRect()\n  let top\n  let left\n  if (placement === PLACEMENTS.BOTTOM) {\n    top = containerScrollTop + rect.top + rect.height\n    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2\n  } else if (placement === PLACEMENTS.LEFT) {\n    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2\n    left = containerScrollLeft + rect.left - tooltipRect.width\n  } else if (placement === PLACEMENTS.RIGHT) {\n    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2\n    // https://github.com/wxsms/uiv/issues/272\n    // add 1px to fix above issue\n    left = containerScrollLeft + rect.left + rect.width + 1\n  } else {\n    top = containerScrollTop + rect.top - tooltipRect.height\n    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2\n  }\n  let viewportEl\n  // viewport option\n  if (isString(viewport)) {\n    viewportEl = document.querySelector(viewport)\n  } else if (isFunction(viewport)) {\n    viewportEl = viewport(trigger)\n  }\n  if (isElement(viewportEl)) {\n    const popoverFix = isPopover ? 11 : 0\n    const viewportReact = viewportEl.getBoundingClientRect()\n    const viewportTop = containerScrollTop + viewportReact.top\n    const viewportLeft = containerScrollLeft + viewportReact.left\n    const viewportBottom = viewportTop + viewportReact.height\n    const viewportRight = viewportLeft + viewportReact.width\n    // fix top\n    if (top < viewportTop) {\n      top = viewportTop\n    } else if (top + tooltipRect.height > viewportBottom) {\n      top = viewportBottom - tooltipRect.height\n    }\n    // fix left\n    if (left < viewportLeft) {\n      left = viewportLeft\n    } else if (left + tooltipRect.width > viewportRight) {\n      left = viewportRight - tooltipRect.width\n    }\n    // fix for popover pointer\n    if (placement === PLACEMENTS.BOTTOM) {\n      top -= popoverFix\n    } else if (placement === PLACEMENTS.LEFT) {\n      left += popoverFix\n    } else if (placement === PLACEMENTS.RIGHT) {\n      left -= popoverFix\n    } else {\n      top += popoverFix\n    }\n  }\n  // set position finally\n  tooltip.style.top = `${top}px`\n  tooltip.style.left = `${left}px`\n}\n\nexport function hasScrollbar (el) {\n  const SCROLL = 'scroll'\n  const hasVScroll = el.scrollHeight > el.clientHeight\n  const style = getComputedStyle(el)\n  return hasVScroll || style.overflow === SCROLL || style.overflowY === SCROLL\n}\n\nexport function toggleBodyOverflow (enable) {\n  const MODAL_OPEN = 'modal-open'\n  const body = document.body\n  if (enable) {\n    removeClass(body, MODAL_OPEN)\n    body.style.paddingRight = null\n  } else {\n    const browsersWithFloatingScrollbar = isIE10() || isIE11()\n    const documentHasScrollbar = hasScrollbar(document.documentElement) || hasScrollbar(document.body)\n    if (documentHasScrollbar && !browsersWithFloatingScrollbar) {\n      body.style.paddingRight = `${getScrollbarWidth()}px`\n    }\n    addClass(body, MODAL_OPEN)\n  }\n}\n\nexport function getClosest (el, selector) {\n  ensureElementMatchesFunction()\n  let parent\n  let _el = el\n  while (_el) {\n    parent = _el.parentElement\n    if (parent && parent.matches(selector)) {\n      return parent\n    }\n    _el = parent\n  }\n  return null\n}\n\nexport function getParents (el, selector, until = null) {\n  ensureElementMatchesFunction()\n  let parents = []\n  let parent = el.parentElement\n  while (parent) {\n    if (parent.matches(selector)) {\n      parents.push(parent)\n    } else if (until && (until === parent || parent.matches(until))) {\n      break\n    }\n    parent = parent.parentElement\n  }\n  return parents\n}\n\nexport function focus (el) {\n  if (!isElement(el)) {\n    return\n  }\n  el.getAttribute('tabindex') ? null : el.setAttribute('tabindex', '-1')\n  el.focus()\n}\n","export function spliceIfExist (arr, item) {\n  if (Array.isArray(arr)) {\n    const index = arr.indexOf(item)\n    if (index >= 0) {\n      arr.splice(index, 1)\n    }\n  }\n}\n\nexport function range (end, start = 0, step = 1) {\n  let arr = []\n  for (let i = start; i < end; i += step) {\n    arr.push(i)\n  }\n  return arr\n}\n\nexport function nodeListToArray (nodeList) {\n  return Array.prototype.slice.call(nodeList || [])\n}\n\nexport function onlyUnique (value, index, self) {\n  return self.indexOf(value) === index\n}\n","import {\n  addClass,\n  removeClass,\n  EVENTS,\n  on,\n  off,\n  getViewportSize,\n  getClosest,\n  getParents\n} from '../../utils/domUtils'\nimport {nodeListToArray} from '../../utils/arrayUtils'\n\nfunction ScrollSpy (element, target = 'body', options = {}) {\n  this.el = element\n  this.opts = Object.assign({}, ScrollSpy.DEFAULTS, options)\n  this.opts.target = target\n  if (target === 'body') {\n    this.scrollElement = window\n  } else {\n    this.scrollElement = document.querySelector(`[id=${target}]`)\n  }\n  this.selector = 'li > a'\n  this.offsets = []\n  this.targets = []\n  this.activeTarget = null\n  this.scrollHeight = 0\n  if (this.scrollElement) {\n    this.refresh()\n    this.process()\n  }\n}\n\nScrollSpy.DEFAULTS = {\n  offset: 10,\n  callback: (ele) => 0\n}\n\nScrollSpy.prototype.getScrollHeight = function () {\n  return this.scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)\n}\n\nScrollSpy.prototype.refresh = function () {\n  this.offsets = []\n  this.targets = []\n  this.scrollHeight = this.getScrollHeight()\n  let list = nodeListToArray(this.el.querySelectorAll(this.selector))\n  const isWindow = this.scrollElement === window\n  list\n    .map(ele => {\n      const href = ele.getAttribute('href')\n      if (/^#./.test(href)) {\n        const doc = document.documentElement\n        const rootEl = isWindow ? document : this.scrollElement\n        const hrefEl = rootEl.querySelector(`[id='${href.slice(1)}']`)\n        const windowScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n        const offset = isWindow ? hrefEl.getBoundingClientRect().top + windowScrollTop : hrefEl.offsetTop + this.scrollElement.scrollTop\n        return [offset, href]\n      } else {\n        return null\n      }\n    })\n    .filter(item => item)\n    .sort((a, b) => a[0] - b[0])\n    .forEach(item => {\n      this.offsets.push(item[0])\n      this.targets.push(item[1])\n    })\n  // console.log(this.offsets, this.targets)\n}\n\nScrollSpy.prototype.process = function () {\n  const isWindow = this.scrollElement === window\n  const scrollTop = (isWindow ? window.pageYOffset : this.scrollElement.scrollTop) + this.opts.offset\n  const scrollHeight = this.getScrollHeight()\n  const scrollElementHeight = isWindow ? getViewportSize().height : this.scrollElement.getBoundingClientRect().height\n  const maxScroll = this.opts.offset + scrollHeight - scrollElementHeight\n  const offsets = this.offsets\n  const targets = this.targets\n  const activeTarget = this.activeTarget\n  let i\n  if (this.scrollHeight !== scrollHeight) {\n    this.refresh()\n  }\n  if (scrollTop >= maxScroll) {\n    return activeTarget !== (i = targets[targets.length - 1]) && this.activate(i)\n  }\n  if (activeTarget && scrollTop < offsets[0]) {\n    this.activeTarget = null\n    return this.clear()\n  }\n  for (i = offsets.length; i--;) {\n    activeTarget !== targets[i] &&\n    scrollTop >= offsets[i] &&\n    (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) &&\n    this.activate(targets[i])\n  }\n}\n\nScrollSpy.prototype.activate = function (target) {\n  this.activeTarget = target\n  this.clear()\n  const selector = this.selector +\n    '[data-target=\"' + target + '\"],' +\n    this.selector + '[href=\"' + target + '\"]'\n  const activeCallback = this.opts.callback\n  let active = nodeListToArray(this.el.querySelectorAll(selector))\n  active.forEach(ele => {\n    getParents(ele, 'li')\n      .forEach(item => {\n        addClass(item, 'active')\n        activeCallback(item)\n      })\n    if (getParents(ele, '.dropdown-menu').length) {\n      addClass(getClosest(ele, 'li.dropdown'), 'active')\n    }\n  })\n}\n\nScrollSpy.prototype.clear = function () {\n  let list = nodeListToArray(this.el.querySelectorAll(this.selector))\n  list.forEach(ele => {\n    getParents(ele, '.active', this.opts.target).forEach(item => {\n      removeClass(item, 'active')\n    })\n  })\n}\n\nconst INSTANCE = '_uiv_scrollspy_instance'\nconst events = [EVENTS.RESIZE, EVENTS.SCROLL]\n\nconst bind = (el, binding) => {\n  // console.log('bind')\n  unbind(el)\n}\n\nconst inserted = (el, binding) => {\n  // console.log('inserted')\n  const scrollSpy = new ScrollSpy(el, binding.arg, binding.value)\n  if (scrollSpy.scrollElement) {\n    scrollSpy.handler = () => {\n      scrollSpy.process()\n    }\n    events.forEach(event => {\n      on(scrollSpy.scrollElement, event, scrollSpy.handler)\n    })\n  }\n  el[INSTANCE] = scrollSpy\n}\n\nconst unbind = (el) => {\n  // console.log('unbind')\n  let instance = el[INSTANCE]\n  if (instance && instance.scrollElement) {\n    events.forEach(event => {\n      off(instance.scrollElement, event, instance.handler)\n    })\n    delete el[INSTANCE]\n  }\n}\n\nconst update = (el, binding) => {\n  // console.log('update')\n  const isArgUpdated = binding.arg !== binding.oldArg\n  const isValueUpdated = binding.value !== binding.oldValue\n  if (isArgUpdated || isValueUpdated) {\n    bind(el, binding)\n    inserted(el, binding)\n  }\n}\n\nexport default {bind, unbind, update, inserted}\n"],"names":["EVENTS","getViewportSize","width","Math","max","document","documentElement","clientWidth","window","innerWidth","height","clientHeight","innerHeight","on","element","event","handler","addEventListener","off","removeEventListener","isElement","el","nodeType","Node","ELEMENT_NODE","ensureElementMatchesFunction","Element","prototype","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","s","ownerDocument","querySelectorAll","i","length","item","addClass","className","classes","split","indexOf","push","join","removeClass","newClasses","l","getClosest","selector","parent","_el","parentElement","getParents","until","parents","nodeListToArray","nodeList","Array","slice","call","ScrollSpy","target","options","opts","babelHelpers.extends","DEFAULTS","scrollElement","querySelector","offsets","targets","activeTarget","scrollHeight","refresh","process","ele","getScrollHeight","body","list","isWindow","map","href","getAttribute","test","doc","rootEl","hrefEl","windowScrollTop","pageYOffset","scrollTop","clientTop","offset","getBoundingClientRect","top","offsetTop","filter","sort","a","b","forEach","scrollElementHeight","maxScroll","activate","clear","undefined","activeCallback","callback","active","INSTANCE","events","RESIZE","SCROLL","bind","binding","inserted","scrollSpy","arg","value","unbind","instance","update","isArgUpdated","oldArg","isValueUpdated","oldValue"],"mappings":"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"}