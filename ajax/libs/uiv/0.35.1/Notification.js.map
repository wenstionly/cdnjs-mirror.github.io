{"version":3,"file":"Notification.js","sources":["../src/utils/objectUtils.js","../src/utils/domUtils.js","../src/utils/arrayUtils.js","../src/components/alert/Alert.vue","../src/services/notification/constants.js","../src/services/notification/Notification.vue","../src/services/notification/Notification.js"],"sourcesContent":["export function isExist (obj) {\n  return typeof obj !== 'undefined' && obj !== null\n}\n\nexport function isFunction (obj) {\n  return typeof obj === 'function'\n}\n\nexport function isNumber (obj) {\n  return typeof obj === 'number'\n}\n\nexport function isString (obj) {\n  return typeof obj === 'string'\n}\n\nexport function isBoolean (obj) {\n  return typeof obj === 'boolean'\n}\n\nexport function isPromiseSupported () {\n  return typeof window !== 'undefined' && isExist(window.Promise)\n}\n","import {isExist, isString, isFunction} from './objectUtils'\n\nexport const EVENTS = {\n  MOUSE_ENTER: 'mouseenter',\n  MOUSE_LEAVE: 'mouseleave',\n  FOCUS: 'focus',\n  BLUR: 'blur',\n  CLICK: 'click',\n  INPUT: 'input',\n  KEY_DOWN: 'keydown',\n  KEY_UP: 'keyup',\n  KEY_PRESS: 'keypress',\n  RESIZE: 'resize',\n  SCROLL: 'scroll',\n  TOUCH_START: 'touchstart',\n  TOUCH_END: 'touchend'\n}\n\nexport const TRIGGERS = {\n  CLICK: 'click',\n  HOVER: 'hover',\n  FOCUS: 'focus',\n  HOVER_FOCUS: 'hover-focus',\n  OUTSIDE_CLICK: 'outside-click',\n  MANUAL: 'manual'\n}\n\nexport const PLACEMENTS = {\n  TOP: 'top',\n  RIGHT: 'right',\n  BOTTOM: 'bottom',\n  LEFT: 'left'\n}\n\nexport function isIE11 () {\n  return !!window.MSInputMethodContext && !!document.documentMode\n}\n\nexport function isIE10 () {\n  return window.navigator.appVersion.indexOf('MSIE 10') !== -1\n}\n\nexport function getComputedStyle (el) {\n  return window.getComputedStyle(el)\n}\n\nexport function getViewportSize () {\n  let width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0)\n  let height = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)\n  return {width, height}\n}\n\nlet scrollbarWidth = null\nlet savedScreenSize = null\n\nexport function getScrollbarWidth (recalculate = false) {\n  let screenSize = getViewportSize()\n  // return directly when already calculated & not force recalculate & screen size not changed\n  if (scrollbarWidth !== null && !recalculate &&\n    screenSize.height === savedScreenSize.height && screenSize.width === savedScreenSize.width) {\n    return scrollbarWidth\n  }\n  if (document.readyState === 'loading') {\n    return null\n  }\n  const div1 = document.createElement('div')\n  const div2 = document.createElement('div')\n  div1.style.width = div2.style.width = div1.style.height = div2.style.height = '100px'\n  div1.style.overflow = 'scroll'\n  div2.style.overflow = 'hidden'\n  document.body.appendChild(div1)\n  document.body.appendChild(div2)\n  scrollbarWidth = Math.abs(div1.scrollHeight - div2.scrollHeight)\n  document.body.removeChild(div1)\n  document.body.removeChild(div2)\n  // save new screen size\n  savedScreenSize = screenSize\n  return scrollbarWidth\n}\n\nexport function on (element, event, handler) {\n  element.addEventListener(event, handler)\n}\n\nexport function off (element, event, handler) {\n  element.removeEventListener(event, handler)\n}\n\nexport function isElement (el) {\n  return el && el.nodeType === Node.ELEMENT_NODE\n}\n\nexport function removeFromDom (el) {\n  isElement(el) && isElement(el.parentNode) && el.parentNode.removeChild(el)\n}\n\nexport function ensureElementMatchesFunction () {\n  if (!Element.prototype.matches) {\n    Element.prototype.matches =\n      Element.prototype.matchesSelector ||\n      Element.prototype.mozMatchesSelector ||\n      Element.prototype.msMatchesSelector ||\n      Element.prototype.oMatchesSelector ||\n      Element.prototype.webkitMatchesSelector ||\n      function (s) {\n        let matches = (this.document || this.ownerDocument).querySelectorAll(s)\n        let i = matches.length\n        while (--i >= 0 && matches.item(i) !== this) {\n        }\n        return i > -1\n      }\n  }\n}\n\nexport function addClass (el, className) {\n  if (!isElement(el)) {\n    return\n  }\n  if (el.className) {\n    let classes = el.className.split(' ')\n    if (classes.indexOf(className) < 0) {\n      classes.push(className)\n      el.className = classes.join(' ')\n    }\n  } else {\n    el.className = className\n  }\n}\n\nexport function removeClass (el, className) {\n  if (!isElement(el)) {\n    return\n  }\n  if (el.className) {\n    let classes = el.className.split(' ')\n    let newClasses = []\n    for (let i = 0, l = classes.length; i < l; i++) {\n      if (classes[i] !== className) {\n        newClasses.push(classes[i])\n      }\n    }\n    el.className = newClasses.join(' ')\n  }\n}\n\nexport function hasClass (el, className) {\n  if (!isElement(el)) {\n    return false\n  }\n  let classes = el.className.split(' ')\n  for (let i = 0, l = classes.length; i < l; i++) {\n    if (classes[i] === className) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function setDropdownPosition (dropdown, trigger, options = {}) {\n  let doc = document.documentElement\n  let containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0)\n  let containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n  let rect = trigger.getBoundingClientRect()\n  let dropdownRect = dropdown.getBoundingClientRect()\n  dropdown.style.right = 'auto'\n  dropdown.style.bottom = 'auto'\n  if (options.menuRight) {\n    dropdown.style.left = containerScrollLeft + rect.left + rect.width - dropdownRect.width + 'px'\n  } else {\n    dropdown.style.left = containerScrollLeft + rect.left + 'px'\n  }\n  if (options.dropup) {\n    dropdown.style.top = containerScrollTop + rect.top - dropdownRect.height - 4 + 'px'\n  } else {\n    dropdown.style.top = containerScrollTop + rect.top + rect.height + 'px'\n  }\n}\n\nexport function isAvailableAtPosition (trigger, popup, placement) {\n  let triggerRect = trigger.getBoundingClientRect()\n  let popupRect = popup.getBoundingClientRect()\n  let viewPortSize = getViewportSize()\n  let top = true\n  let right = true\n  let bottom = true\n  let left = true\n  switch (placement) {\n    case PLACEMENTS.TOP:\n      top = triggerRect.top >= popupRect.height\n      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2\n      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width\n      break\n    case PLACEMENTS.BOTTOM:\n      bottom = triggerRect.bottom + popupRect.height <= viewPortSize.height\n      left = triggerRect.left + triggerRect.width / 2 >= popupRect.width / 2\n      right = triggerRect.right - triggerRect.width / 2 + popupRect.width / 2 <= viewPortSize.width\n      break\n    case PLACEMENTS.RIGHT:\n      right = triggerRect.right + popupRect.width <= viewPortSize.width\n      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2\n      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height\n      break\n    case PLACEMENTS.LEFT:\n      left = triggerRect.left >= popupRect.width\n      top = triggerRect.top + triggerRect.height / 2 >= popupRect.height / 2\n      bottom = triggerRect.bottom - triggerRect.height / 2 + popupRect.height / 2 <= viewPortSize.height\n      break\n  }\n  return top && right && bottom && left\n}\n\nexport function setTooltipPosition (tooltip, trigger, placement, auto, appendToSelector, viewport) {\n  if (!isElement(tooltip) || !isElement(trigger)) {\n    return\n  }\n  const isPopover = tooltip && tooltip.className && tooltip.className.indexOf('popover') >= 0\n  let containerScrollTop\n  let containerScrollLeft\n  if (!isExist(appendToSelector) || appendToSelector === 'body') {\n    const doc = document.documentElement\n    containerScrollLeft = (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0)\n    containerScrollTop = (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0)\n  } else {\n    const container = document.querySelector(appendToSelector)\n    containerScrollLeft = container.scrollLeft\n    containerScrollTop = container.scrollTop\n  }\n  // auto adjust placement\n  if (auto) {\n    // Try: right -> bottom -> left -> top\n    // Cause the default placement is top\n    let placements = [PLACEMENTS.RIGHT, PLACEMENTS.BOTTOM, PLACEMENTS.LEFT, PLACEMENTS.TOP]\n    // The class switch helper function\n    const changePlacementClass = (placement) => {\n      // console.log(placement)\n      placements.forEach(placement => {\n        removeClass(tooltip, placement)\n      })\n      addClass(tooltip, placement)\n    }\n    // No need to adjust if the default placement fits\n    if (!isAvailableAtPosition(trigger, tooltip, placement)) {\n      for (let i = 0, l = placements.length; i < l; i++) {\n        // Re-assign placement class\n        changePlacementClass(placements[i])\n        // Break if new placement fits\n        if (isAvailableAtPosition(trigger, tooltip, placements[i])) {\n          placement = placements[i]\n          break\n        }\n      }\n      changePlacementClass(placement)\n    }\n  }\n  // fix left and top for tooltip\n  let rect = trigger.getBoundingClientRect()\n  let tooltipRect = tooltip.getBoundingClientRect()\n  let top\n  let left\n  if (placement === PLACEMENTS.BOTTOM) {\n    top = containerScrollTop + rect.top + rect.height\n    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2\n  } else if (placement === PLACEMENTS.LEFT) {\n    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2\n    left = containerScrollLeft + rect.left - tooltipRect.width\n  } else if (placement === PLACEMENTS.RIGHT) {\n    top = containerScrollTop + rect.top + rect.height / 2 - tooltipRect.height / 2\n    // https://github.com/wxsms/uiv/issues/272\n    // add 1px to fix above issue\n    left = containerScrollLeft + rect.left + rect.width + 1\n  } else {\n    top = containerScrollTop + rect.top - tooltipRect.height\n    left = containerScrollLeft + rect.left + rect.width / 2 - tooltipRect.width / 2\n  }\n  let viewportEl\n  // viewport option\n  if (isString(viewport)) {\n    viewportEl = document.querySelector(viewport)\n  } else if (isFunction(viewport)) {\n    viewportEl = viewport(trigger)\n  }\n  if (isElement(viewportEl)) {\n    const popoverFix = isPopover ? 11 : 0\n    const viewportReact = viewportEl.getBoundingClientRect()\n    const viewportTop = containerScrollTop + viewportReact.top\n    const viewportLeft = containerScrollLeft + viewportReact.left\n    const viewportBottom = viewportTop + viewportReact.height\n    const viewportRight = viewportLeft + viewportReact.width\n    // fix top\n    if (top < viewportTop) {\n      top = viewportTop\n    } else if (top + tooltipRect.height > viewportBottom) {\n      top = viewportBottom - tooltipRect.height\n    }\n    // fix left\n    if (left < viewportLeft) {\n      left = viewportLeft\n    } else if (left + tooltipRect.width > viewportRight) {\n      left = viewportRight - tooltipRect.width\n    }\n    // fix for popover pointer\n    if (placement === PLACEMENTS.BOTTOM) {\n      top -= popoverFix\n    } else if (placement === PLACEMENTS.LEFT) {\n      left += popoverFix\n    } else if (placement === PLACEMENTS.RIGHT) {\n      left -= popoverFix\n    } else {\n      top += popoverFix\n    }\n  }\n  // set position finally\n  tooltip.style.top = `${top}px`\n  tooltip.style.left = `${left}px`\n}\n\nexport function hasScrollbar (el) {\n  const SCROLL = 'scroll'\n  const hasVScroll = el.scrollHeight > el.clientHeight\n  const style = getComputedStyle(el)\n  return hasVScroll || style.overflow === SCROLL || style.overflowY === SCROLL\n}\n\nexport function toggleBodyOverflow (enable) {\n  const MODAL_OPEN = 'modal-open'\n  const body = document.body\n  if (enable) {\n    removeClass(body, MODAL_OPEN)\n    body.style.paddingRight = null\n  } else {\n    const browsersWithFloatingScrollbar = isIE10() || isIE11()\n    const documentHasScrollbar = hasScrollbar(document.documentElement) || hasScrollbar(document.body)\n    if (documentHasScrollbar && !browsersWithFloatingScrollbar) {\n      body.style.paddingRight = `${getScrollbarWidth()}px`\n    }\n    addClass(body, MODAL_OPEN)\n  }\n}\n\nexport function getClosest (el, selector) {\n  ensureElementMatchesFunction()\n  let parent\n  let _el = el\n  while (_el) {\n    parent = _el.parentElement\n    if (parent && parent.matches(selector)) {\n      return parent\n    }\n    _el = parent\n  }\n  return null\n}\n\nexport function getParents (el, selector, until = null) {\n  ensureElementMatchesFunction()\n  let parents = []\n  let parent = el.parentElement\n  while (parent) {\n    if (parent.matches(selector)) {\n      parents.push(parent)\n    } else if (until && (until === parent || parent.matches(until))) {\n      break\n    }\n    parent = parent.parentElement\n  }\n  return parents\n}\n\nexport function focus (el) {\n  if (!isElement(el)) {\n    return\n  }\n  el.getAttribute('tabindex') ? null : el.setAttribute('tabindex', '-1')\n  el.focus()\n}\n","export function spliceIfExist (arr, item) {\n  if (Array.isArray(arr)) {\n    const index = arr.indexOf(item)\n    if (index >= 0) {\n      arr.splice(index, 1)\n    }\n  }\n}\n\nexport function range (end, start = 0, step = 1) {\n  let arr = []\n  for (let i = start; i < end; i += step) {\n    arr.push(i)\n  }\n  return arr\n}\n\nexport function nodeListToArray (nodeList) {\n  return Array.prototype.slice.call(nodeList || [])\n}\n\nexport function onlyUnique (value, index, self) {\n  return self.indexOf(value) === index\n}\n","<template>\n  <div role=\"alert\" :class=\"alertClass\">\n    <button type=\"button\" class=\"close\" aria-label=\"Close\" v-if=\"dismissible\" @click=\"closeAlert\">\n      <span aria-hidden=\"true\">&times;</span>\n    </button>\n    <slot></slot>\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      dismissible: {\n        type: Boolean,\n        default: false\n      },\n      duration: {\n        type: Number,\n        default: 0\n      },\n      type: {\n        type: String,\n        default: 'info'\n      }\n    },\n    data () {\n      return {\n        timeout: 0\n      }\n    },\n    computed: {\n      alertClass () {\n        return {\n          'alert': true,\n          [`alert-${this.type}`]: Boolean(this.type),\n          'alert-dismissible': this.dismissible\n        }\n      }\n    },\n    methods: {\n      closeAlert () {\n        clearTimeout(this.timeout)\n        this.$emit('dismissed')\n      }\n    },\n    mounted () {\n      if (this.duration > 0) {\n        this.timeout = setTimeout(this.closeAlert, this.duration)\n      }\n    },\n    destroyed () {\n      clearTimeout(this.timeout)\n    }\n  }\n</script>\n","export const TYPES = {\n  SUCCESS: 'success',\n  INFO: 'info',\n  DANGER: 'danger',\n  WARNING: 'warning'\n}\n\nexport const PLACEMENTS = {\n  TOP_LEFT: 'top-left',\n  TOP_RIGHT: 'top-right',\n  BOTTOM_LEFT: 'bottom-left',\n  BOTTOM_RIGHT: 'bottom-right'\n}\n","<template>\n  <alert\n    class=\"fade\"\n    :class=\"customClass\"\n    :style=\"styles\"\n    :type=\"type\"\n    :duration=\"duration\"\n    :dismissible=\"dismissible\"\n    @dismissed=\"onDismissed\">\n    <div class=\"media\" style=\"margin: 0\">\n      <div class=\"media-left\" v-if=\"icons\">\n        <span :class=\"icons\" style=\"font-size: 1.5em\"></span>\n      </div>\n      <div class=\"media-body\">\n        <div class=\"media-heading\" v-if=\"title\"><b>{{title}}</b></div>\n        <div v-if=\"html\" v-html=\"content\"></div>\n        <div v-else>{{content}}</div>\n      </div>\n    </div>\n  </alert>\n</template>\n\n<script>\n  import {addClass, removeClass} from '../../utils/domUtils'\n  import {isString} from '../../utils/objectUtils'\n  import Alert from '../../components/alert/Alert.vue'\n  import {TYPES, PLACEMENTS} from './constants'\n\n  const IN_CLASS = 'in'\n  const ICON = 'glyphicon'\n  const WIDTH = 300\n  const TRANSITION_DURATION = 300\n\n  export default {\n    components: {Alert},\n    props: {\n      title: String,\n      content: String,\n      html: {\n        type: Boolean,\n        default: false\n      },\n      duration: {\n        type: Number,\n        default: 5000\n      },\n      dismissible: {\n        type: Boolean,\n        default: true\n      },\n      type: String,\n      placement: String,\n      icon: String,\n      customClass: null,\n      cb: {\n        type: Function,\n        required: true\n      },\n      queue: {\n        type: Array,\n        required: true\n      },\n      offsetY: {\n        type: Number,\n        default: 15\n      },\n      offsetX: {\n        type: Number,\n        default: 15\n      },\n      offset: {\n        type: Number,\n        default: 15\n      }\n    },\n    data () {\n      return {\n        height: 0,\n        top: 0,\n        horizontal: this.placement === PLACEMENTS.TOP_LEFT || this.placement === PLACEMENTS.BOTTOM_LEFT ? 'left' : 'right',\n        vertical: this.placement === PLACEMENTS.TOP_LEFT || this.placement === PLACEMENTS.TOP_RIGHT ? 'top' : 'bottom'\n      }\n    },\n    created () {\n      // get prev notifications total height in the queue\n      this.top = this.getTotalHeightOfQueue(this.queue)\n    },\n    mounted () {\n      const el = this.$el\n      el.style[this.vertical] = this.top + 'px'\n      this.$nextTick(() => {\n        el.style[this.horizontal] = `-${WIDTH}px`\n        this.height = el.offsetHeight\n        el.style[this.horizontal] = `${this.offsetX}px`\n        addClass(el, IN_CLASS)\n      })\n    },\n    computed: {\n      styles () {\n        let queue = this.queue\n        let thisIndex = queue.indexOf(this)\n        return {\n          position: 'fixed',\n          [this.vertical]: `${this.getTotalHeightOfQueue(queue, thisIndex)}px`,\n          width: `${WIDTH}px`,\n          transition: `all ${TRANSITION_DURATION / 1000}s ease-in-out`\n        }\n      },\n      icons () {\n        if (isString(this.icon)) {\n          return this.icon\n        }\n        switch (this.type) {\n          case TYPES.INFO:\n          case TYPES.WARNING:\n            return `${ICON} ${ICON}-info-sign`\n          case TYPES.SUCCESS:\n            return `${ICON} ${ICON}-ok-sign`\n          case TYPES.DANGER:\n            return `${ICON} ${ICON}-remove-sign`\n          default:\n            return null\n        }\n      }\n    },\n    methods: {\n      getTotalHeightOfQueue (queue, lastIndex = queue.length) {\n        let totalHeight = this.offsetY\n        for (let i = 0; i < lastIndex; i++) {\n          totalHeight += queue[i].height + this.offset\n        }\n        return totalHeight\n      },\n      onDismissed () {\n        removeClass(this.$el, IN_CLASS)\n        setTimeout(this.cb, TRANSITION_DURATION)\n      }\n    }\n  }\n</script>\n","import {removeFromDom} from '../../utils/domUtils'\nimport {spliceIfExist} from '../../utils/arrayUtils'\nimport {isFunction, isExist, isString, isPromiseSupported} from '../../utils/objectUtils'\nimport Notification from './Notification.vue'\nimport {PLACEMENTS} from './constants'\nimport Vue from 'vue'\n\nconst queues = {\n  [PLACEMENTS.TOP_LEFT]: [],\n  [PLACEMENTS.TOP_RIGHT]: [],\n  [PLACEMENTS.BOTTOM_LEFT]: [],\n  [PLACEMENTS.BOTTOM_RIGHT]: []\n}\n\nconst destroy = (queue, instance) => {\n  // console.log('destroyNotification')\n  removeFromDom(instance.$el)\n  instance.$destroy()\n  spliceIfExist(queue, instance)\n}\n\nconst init = (options, cb, resolve = null, reject = null) => {\n  const placement = options.placement\n  const queue = queues[placement]\n  // check if placement is valid\n  if (!isExist(queue)) {\n    return\n  }\n  /* istanbul ignore else */\n  // `error` alias of `danger`\n  if (options.type === 'error') {\n    options.type = 'danger'\n  }\n  let instance = new Vue({\n    extends: Notification,\n    propsData: {\n      queue,\n      placement,\n      ...options,\n      cb (msg) {\n        destroy(queue, instance)\n        if (isFunction(cb)) {\n          cb(msg)\n        } else if (resolve && reject) {\n          resolve(msg)\n        }\n      }\n    }\n  })\n  instance.$mount()\n  document.body.appendChild(instance.$el)\n  queue.push(instance)\n}\n\nconst _notify = (options = {}, cb) => {\n  // simplify usage: pass string as option.content\n  if (isString(options)) {\n    options = {\n      content: options\n    }\n  }\n  // set default placement as top-right\n  if (!isExist(options.placement)) {\n    options.placement = PLACEMENTS.TOP_RIGHT\n  }\n  if (isPromiseSupported()) {\n    return new Promise((resolve, reject) => {\n      init(options, cb, resolve, reject)\n    })\n  } else {\n    init(options, cb)\n  }\n}\n\nfunction _notify2 (type, args) {\n  if (isString(args)) {\n    _notify({\n      content: args,\n      type\n    })\n  } else {\n    _notify({\n      ...args,\n      type\n    })\n  }\n}\n\nconst notify = Object.defineProperties(_notify, {\n  success: {\n    configurable: false,\n    writable: false,\n    value (args) {\n      _notify2('success', args)\n    }\n  },\n  info: {\n    configurable: false,\n    writable: false,\n    value (args) {\n      _notify2('info', args)\n    }\n  },\n  warning: {\n    configurable: false,\n    writable: false,\n    value (args) {\n      _notify2('warning', args)\n    }\n  },\n  danger: {\n    configurable: false,\n    writable: false,\n    value (args) {\n      _notify2('danger', args)\n    }\n  },\n  error: {\n    configurable: false,\n    writable: false,\n    value (args) {\n      _notify2('danger', args)\n    }\n  },\n  dismissAll: {\n    configurable: false,\n    writable: false,\n    value () {\n      for (let key in queues) {\n        /* istanbul ignore else */\n        if (queues.hasOwnProperty(key)) {\n          queues[key].forEach(instance => {\n            instance.onDismissed()\n          })\n        }\n      }\n    }\n  }\n})\n\nexport default {notify}\n"],"names":["isExist","obj","isFunction","isString","isPromiseSupported","window","Promise","isElement","el","nodeType","Node","ELEMENT_NODE","removeFromDom","parentNode","removeChild","addClass","className","classes","split","indexOf","push","join","removeClass","newClasses","i","l","length","spliceIfExist","arr","item","Array","isArray","index","splice","render","Boolean","Number","String","type","dismissible","timeout","$emit","duration","setTimeout","closeAlert","TYPES","PLACEMENTS","IN_CLASS","ICON","WIDTH","TRANSITION_DURATION","Alert","Function","placement","TOP_LEFT","BOTTOM_LEFT","TOP_RIGHT","top","getTotalHeightOfQueue","queue","$el","style","vertical","$nextTick","horizontal","height","offsetHeight","offsetX","thisIndex","icon","INFO","WARNING","SUCCESS","DANGER","lastIndex","totalHeight","offsetY","offset","cb","queues","BOTTOM_RIGHT","destroy","instance","$destroy","init","options","resolve","reject","Vue","Notification","msg","$mount","body","appendChild","_notify","_notify2","args","notify","Object","defineProperties","key","hasOwnProperty","forEach","onDismissed"],"mappings":"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"}